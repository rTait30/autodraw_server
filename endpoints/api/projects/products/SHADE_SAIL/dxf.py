"""SHADE_SAIL DXF generation.

Draws each shade sail (each product) side-by-side (left to right) showing:
  - Plan view (posts as circles, perimeter edges)
  - Post height indicator (small vertical line + caps) per point
  - Height annotation text below each post

Relies on attributes structure:
  products[i].attributes.points[LETTER].height
  products[i].attributes.positions[LETTER] = {x, y}
  products[i].attributes.pointCount
"""

import math
import tempfile
from datetime import datetime, timezone
from flask import send_file
from sqlalchemy import JSON
from endpoints.api.projects.shared.dxf_utils import new_doc_mm

import json as JSON_py


def _safe_num(v):
    if v in (None, "", " "):
        return None
    try:
        return float(str(v).strip())
    except (ValueError, TypeError):
        return None


def generate_dxf(project, download_name: str):
    """Lean DXF: accepts a standalone plain project dict and draws sails.

    Expected minimal shape:
      project = {
        "general": { "name": str, ... },
        "products": [ { "name": str, "productIndex": int, "attributes": { ... } }, ... ]
      }
    """
    doc, msp = new_doc_mm()

    # Expect a plain dict, not a DB-attached object
    if not isinstance(project, dict) or not project.get("products"):
        msp.add_text("SHADE SAIL DXF no project/products", dxfattribs={"layer": "PEN", "char_height": 60}).set_placement((100, 200))
        tmp = tempfile.NamedTemporaryFile(suffix=".dxf", delete=False)
        tmp_path = tmp.name
        tmp.close()
        doc.saveas(tmp_path)
        return send_file(tmp_path, mimetype="application/dxf", as_attachment=True, download_name=download_name,
                         max_age=0, etag=False, conditional=False, last_modified=None)

    circle_radius = 50.0
    cap_half_width = 30.0
    height_line_offset = 300.0  # not used for poles; kept for optional side indicators
    x_offset = 0.0
    spacing = 8000.0
    bbox_buffer = 200.0  # small buffer around bounding box (plan units)

    print("project (plain):", type(project))

    gen = project.get("general") or {}
    project_name = gen.get("name") or "Unnamed"
    products_list = project.get("products") or []

    project_desc = f"Project: {project_name} | Sails: {len(products_list)}"

    date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    # Title
    msp.add_mtext(project_desc, dxfattribs={"layer": "INFO", "char_height": 1000}).set_location((-3000, 6000))
    msp.add_mtext(f"Generated by AutoDraw v00.02 at {date}", dxfattribs={"layer": "INFO", "char_height": 500}).set_location((-3000, 4500))
    msp.add_mtext(JSON_py.dumps(project), dxfattribs={"layer": "INFO", "char_height": 20}).set_location((-3000, 3500))

    # msp.add_text("Units: raw JSON; Perimeter in 3D", dxfattribs={"layer": "PEN", "height": 50}).set_placement((0, -600))
    
    for idx, pp in enumerate(products_list):
        attrs = (pp.get("attributes") or {})
        positions = attrs.get("positions") or {}
        points = attrs.get("points") or {}
        point_count = attrs.get("pointCount") or len(positions)

        # Quick bbox for horizontal offset progression and drawing
        xs = [(_safe_num(p.get("x")) or 0.0) for p in positions.values()]
        ys = [(_safe_num(p.get("y")) or 0.0) for p in positions.values()]
        min_x = min(xs) if xs else 0.0
        max_x = max(xs) if xs else 0.0
        min_y = min(ys) if ys else 0.0
        max_y = max(ys) if ys else 0.0
        width_local = (max_x - min_x)

        post_xy = {}

        edge_meter = attrs.get('edgeMeter', 0)
        perimeter = attrs.get('perimeter', 0)
        
        # Main product title
        product_title = f"Sail: {pp.get('productIndex', idx)} | {pp.get('name') or 'Unnamed'} | Points: {point_count}"
        msp.add_mtext(product_title, dxfattribs={"layer": "INFO", "char_height": 300}).set_location((x_offset - 3000, 3000))
        
        # Details on separate line, smaller text
        product_details = f"Material: {attrs.get('fabricType')} {attrs.get('colour')} | Perimeter: {int(perimeter)}mm | Edge Meter: {edge_meter}m"
        msp.add_mtext(product_details, dxfattribs={"layer": "INFO", "char_height": 200}).set_location((x_offset - 3000, 2600))
        # Compute center in 3D (using pre-calculated centroid)
        centroid = attrs.get("centroid") or {"x": 0.0, "y": 0.0, "z": 0.0}
        cx_local = _safe_num(centroid.get("x")) or 0.0
        cy_local = _safe_num(centroid.get("y")) or 0.0
        cz_local = _safe_num(centroid.get("z")) or 0.0
        
        cx = x_offset + (cx_local - min_x)
        cy = cy_local
        cz = cz_local

        # Draw posts and annotations
        for label, pos in positions.items():
            rx = _safe_num(pos.get("x")) or 0.0
            ry = _safe_num(pos.get("y")) or 0.0
            # Use raw units; positive Y upward
            x = x_offset + (rx - min_x)
            y = ry

            # Z from points height
            h_raw = (points.get(label) or {}).get("height")
            z = _safe_num(h_raw) or 0.0

            print (f"  Post {label} XYZ: {x},{y},{z}")

            post_xy[label] = (x, y, z)

            # 2D circle + 3D point
            msp.add_circle((x, y, z), circle_radius, dxfattribs={"layer": "MARK"})
            msp.add_point((x, y, z), dxfattribs={"layer": "MARK"})

            # Draw pole as true vertical line at the post location (3D)
            # From ground z=0 to top z=z at same (x,y)
            if z > 0:
                msp.add_line((x, y, 0), (x, y, z), dxfattribs={"layer": "MARK"})

            # Labels - place away from center
            point_data = points.get(label) or {}
            fitting = point_data.get("cornerFitting", "")
            hardware = point_data.get("tensionHardware", "")
            allowance = _safe_num(point_data.get("tensionAllowance")) or 0
            extra = []
            if label == attrs.get("exitPoint"):
                extra.append("Exit")
            if label == attrs.get("logoPoint"):
                extra.append("Logo")
            extra_str = " (" + ", ".join(extra) + ")" if extra else ""
            info = f"{extra_str}\nH: {int(round(z))}mm\nFitting: {fitting}\nHardware: {hardware}\nAllowance: {allowance}mm"
            # Position text away from post, away from center
            dx = x - cx
            dy = y - cy
            mag = math.sqrt(dx**2 + dy**2) or 1.0
            ux = dx / mag
            uy = dy / mag
            offset_distance = 1200.0
            text_x = x + ux * offset_distance
            text_y = y + uy * offset_distance
            msp.add_mtext(f"{label}", dxfattribs={"layer": "INFO", "char_height": 200}).set_location((text_x, text_y + 1000, z))
            msp.add_mtext(info, dxfattribs={"layer": "INFO", "char_height": 100}).set_location((text_x, text_y, z), attachment_point=8)
            msp.add_mtext(f"X:{round(rx,2)} Y:{round(ry,2)} Z:{round(z,2)}", dxfattribs={"layer": "INFO", "char_height": 100}).set_location((text_x - 1000, text_y - 60, z))


        # Draw center point (after posts)
        if positions:
            msp.add_point((cx, cy, cz), dxfattribs={"layer": "MARK"})
            msp.add_circle((cx, cy, cz), 35.0, dxfattribs={"layer": "MARK"})

        # Perimeter in 3D using A..N order with edge labels
        order = [chr(65 + i) for i in range(point_count)]
        dimensions = attrs.get('dimensions') or {}
        for i in range(point_count):
            a = order[i]
            b = order[(i + 1) % point_count]
            if a in post_xy and b in post_xy:
                # Draw perimeter edge
                msp.add_line(post_xy[a], post_xy[b], dxfattribs={"layer": "MARK"})
                # Add edge label at midpoint
                edge_key = f"{a}{b}"
                edge_length = _safe_num(dimensions.get(edge_key))
                if edge_length:
                    mid_x = (post_xy[a][0] + post_xy[b][0]) / 2
                    mid_y = (post_xy[a][1] + post_xy[b][1]) / 2
                    mid_z = (post_xy[a][2] + post_xy[b][2]) / 2
                    edge_label = f"{edge_key}\n{int(round(edge_length))}mm"
                    msp.add_mtext(edge_label, dxfattribs={"layer": "PEN", "char_height": 80, "color": 3, "bg_fill": 1, "bg_fill_color": 7}).set_location((mid_x, mid_y, mid_z), attachment_point=5)

        # Draw diagonal lines (thinner, less apparent) with labels
        for i in range(point_count):
            for j in range(i + 2, point_count):
                # Skip adjacent edges (already drawn as perimeter)
                if j == (i + 1) % point_count or i == (j + 1) % point_count:
                    continue
                a = order[i]
                b = order[j]
                diag_key_ab = f"{a}{b}"
                diag_key_ba = f"{b}{a}"
                diag_length = _safe_num(dimensions.get(diag_key_ab)) or _safe_num(dimensions.get(diag_key_ba))
                if diag_length and a in post_xy and b in post_xy:
                    # Draw thin diagonal line
                    msp.add_line(post_xy[a], post_xy[b], dxfattribs={"layer": "PEN", "color": 8, "lineweight": -1})  # color 8 = gray, thin line
                    # Add diagonal label at midpoint
                    mid_x = (post_xy[a][0] + post_xy[b][0]) / 2
                    mid_y = (post_xy[a][1] + post_xy[b][1]) / 2
                    mid_z = (post_xy[a][2] + post_xy[b][2]) / 2
                    diag_label = f"{a}{b}\n{int(round(diag_length))}mm"
                    msp.add_mtext(diag_label, dxfattribs={"layer": "PEN", "char_height": 60, "color": 8, "bg_fill": 1, "bg_fill_color": 7}).set_location((mid_x, mid_y, mid_z), attachment_point=5)

        # Workpoints: 3D offset from each post toward 3D center by tensionAllowance
        workpoints_data = attrs.get("workpoints") or {}
        workpoints = {}
        for label, pos in positions.items():
            # Get pre-calculated workpoint
            wp = workpoints_data.get(label)
            if wp:
                wx_local = _safe_num(wp.get("x")) or 0.0
                wy_local = _safe_num(wp.get("y")) or 0.0
                wz_local = _safe_num(wp.get("z")) or 0.0
                
                wx = x_offset + (wx_local - min_x)
                wy = wy_local
                wz = wz_local
                
                workpoints[label] = (wx, wy, wz)
                
                # draw workpoint (red)
                msp.add_circle((wx, wy, wz), 30.0, dxfattribs={"layer": "PEN", "color": 1})
                msp.add_point((wx, wy, wz), dxfattribs={"layer": "PEN", "color": 1})
                # line from post to workpoint
                if label in post_xy:
                    msp.add_line(post_xy[label], workpoints[label], dxfattribs={"layer": "PEN", "color": 1})

        # Draw polygon connecting workpoints in 3D (red)
        for i in range(point_count):
            a = order[i]
            b = order[(i + 1) % point_count]
            if a in workpoints and b in workpoints:
                msp.add_line(workpoints[a], workpoints[b], dxfattribs={"layer": "PEN", "color": 1})

        # Advance offset; if width_local is zero (degenerate), still move by spacing
        advance = width_local if width_local > 0 else 0.0
        x_offset += advance + spacing

    # Footer

    tmp = tempfile.NamedTemporaryFile(suffix=".dxf", delete=False)
    tmp_path = tmp.name
    tmp.close()
    doc.saveas(tmp_path)

    return send_file(
        tmp_path,
        mimetype="application/dxf",
        as_attachment=True,
        download_name=download_name,
        max_age=0,
        etag=False,
        conditional=False,
        last_modified=None,
    )


__all__ = ["generate_dxf"]
