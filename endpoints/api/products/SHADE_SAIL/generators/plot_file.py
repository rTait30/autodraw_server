import math
import tempfile
from datetime import datetime, timezone
from flask import send_file
from sqlalchemy import JSON
from endpoints.api.projects.shared.dxf_utils import new_doc_mm
import json as JSON_py

def get_metadata():
    return {
        "id": "work_model",
        "name": "Work Model",
        "type": "dxf"
    }

def generate(project, **kwargs):
    """
    Generates a DXF plot file for the SHADE_SAIL product.
    """
    project_name = project.get("general", {}).get("name", "Unnamed")
    filename = f"{project_name}_workmodel.dxf"
    return generate_dxf(project, filename)

def _safe_num(v):
    if v in (None, "", " "):
        return None
    try:
        return float(str(v).strip())
    except (ValueError, TypeError):
        return None


def _escape_mtext(text):
    """Escape special characters for DXF MTEXT content."""
    if not text:
        return ""
    # Escape backslashes first, then braces.
    # Note: We do not escape newlines here; ezdxf handles \n as line breaks.
    return text.replace("\\", "\\\\").replace("{", "\\{").replace("}", "\\}")


def get_drawing_data(project):
    """
    Extracts drawing entities from the project dictionary.
    Returns a list of dicts: {"type": ...,  ...}
    """
    data_list = []

    # Expect a plain dict, not a DB-attached object
    if not isinstance(project, dict) or not project.get("products"):
        data_list.append({
            "type": "text",
            "text": "SHADE SAIL DXF no project/products",
            "dxfattribs": {"layer": "AD_PEN", "char_height": 60},
            "location": (100, 200)
        })
        return data_list

    circle_radius = 50.0
    cap_half_width = 30.0
    height_line_offset = 300.0  # not used for poles; kept for optional side indicators
    x_offset = 0.0
    spacing = 8000.0
    bbox_buffer = 200.0  # small buffer around bounding box (plan units)

    gen = project.get("general") or {}
    project_name = gen.get("name") or "Unnamed"
    products_list = project.get("products") or []

    project_desc = f"Project: {project_name} | Sails: {len(products_list)}"

    date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    # Title
    data_list.append({
        "type": "mtext",
        "text": project_desc,
        "dxfattribs": {"layer": "AD_INFO", "char_height": 1000},
        "location": (-3000, 6000)
    })
    data_list.append({
        "type": "mtext",
        "text": f"Generated by AutoDraw v00.02 at {date}",
        "dxfattribs": {"layer": "AD_INFO", "char_height": 500},
        "location": (-3000, 4500)
    })
    
    # JSON Dump
    # Use indent=2 for readability. Escape braces so MTEXT doesn't interpret them as grouping.
    json_str = JSON_py.dumps(project, indent=2)
    data_list.append({
        "type": "mtext",
        "text": _escape_mtext(json_str),
        "dxfattribs": {"layer": "AD_INFO", "char_height": 20},
        "location": (-4000, 3500)
    })

    for idx, pp in enumerate(products_list):
        attrs = (pp.get("attributes") or {})
        positions = attrs.get("positions") or {}
        points = attrs.get("points") or {}
        point_count = attrs.get("pointCount") or len(positions)

        # Quick bbox for horizontal offset progression and drawing
        xs = [(_safe_num(p.get("x")) or 0.0) for p in positions.values()]
        ys = [(_safe_num(p.get("y")) or 0.0) for p in positions.values()]
        min_x = min(xs) if xs else 0.0
        max_x = max(xs) if xs else 0.0
        width_local = (max_x - min_x)

        post_xy = {}

        edge_meter = attrs.get('edgeMeter', 0)
        perimeter = attrs.get('perimeter', 0)
        
        # Main product title
        product_title = f"Sail: {pp.get('productIndex', idx)} | {pp.get('name') or 'Unnamed'} | Points: {point_count}"
        data_list.append({
            "type": "mtext",
            "text": product_title,
            "dxfattribs": {"layer": "AD_INFO", "char_height": 300},
            "location": (x_offset - 3000, 3000)
        })
        
        # Details on separate line, smaller text
        product_details = f"Material: {attrs.get('fabricType')} {attrs.get('colour')} | Perimeter: {int(perimeter)}mm | Edge Meter: {edge_meter}m"
        data_list.append({
            "type": "mtext",
            "text": product_details,
            "dxfattribs": {"layer": "AD_INFO", "char_height": 200},
            "location": (x_offset - 3000, 2600)
        })
        # Compute center in 3D (using pre-calculated centroid)
        centroid = attrs.get("centroid") or {"x": 0.0, "y": 0.0, "z": 0.0}
        cx_local = _safe_num(centroid.get("x")) or 0.0
        cy_local = _safe_num(centroid.get("y")) or 0.0
        cz_local = _safe_num(centroid.get("z")) or 0.0
        
        cx = x_offset + (cx_local - min_x)
        cy = cy_local
        cz = cz_local

        # Draw posts and annotations
        for label, pos in positions.items():
            rx = _safe_num(pos.get("x")) or 0.0
            ry = _safe_num(pos.get("y")) or 0.0
            # Use raw units; positive Y upward
            x = x_offset + (rx - min_x)
            y = ry

            # Z from points height
            h_raw = (points.get(label) or {}).get("height")
            z = _safe_num(h_raw) or 0.0

            post_xy[label] = (x, y, z)

            # 2D circle + 3D point
            data_list.append({
                "type": "circle",
                "center": (x, y, z),
                "radius": circle_radius,
                "dxfattribs": {"layer": "AD_STRUCTURE"}
            })
            data_list.append({
                "type": "point",
                "location": (x, y, z),
                "dxfattribs": {"layer": "AD_STRUCTURE"}
            })

            # Draw pole as true vertical line at the post location (3D)
            # From ground z=0 to top z=z at same (x,y)
            if z > 0:
                data_list.append({
                    "type": "line",
                    "start": (x, y, 0),
                    "end": (x, y, z),
                    "dxfattribs": {"layer": "AD_STRUCTURE"}
                })

            # Labels - place away from center
            point_data = points.get(label) or {}
            fitting = point_data.get("cornerFitting", "")
            hardware = point_data.get("tensionHardware", "")
            allowance = _safe_num(point_data.get("tensionAllowance")) or 0
            extra = []
            if label == attrs.get("exitPoint"):
                extra.append("Exit")
            if label == attrs.get("logoPoint"):
                extra.append("Logo")
            extra_str = " (" + ", ".join(extra) + ")" if extra else ""
            info = f"{extra_str}\nH: {int(round(z))}mm\nFitting: {fitting}\nHardware: {hardware}\nAllowance: {allowance}mm"
            # Position text away from post, away from center
            dx = x - cx
            dy = y - cy
            mag = math.sqrt(dx**2 + dy**2) or 1.0
            ux = dx / mag
            uy = dy / mag
            offset_distance = 1200.0
            text_x = x + ux * offset_distance
            text_y = y + uy * offset_distance
            
            data_list.append({
                "type": "mtext",
                "text": f"{label}",
                "dxfattribs": {"layer": "AD_INFO", "char_height": 200},
                "location": (text_x, text_y + 1000, z)
            })
            data_list.append({
                "type": "mtext",
                "text": info,
                "dxfattribs": {"layer": "AD_INFO", "char_height": 100},
                "location": (text_x, text_y, z),
                "attachment_point": 8
            })
            data_list.append({
                "type": "mtext",
                "text": f"X:{round(rx,2)} Y:{round(ry,2)} Z:{round(z,2)}",
                "dxfattribs": {"layer": "AD_INFO", "char_height": 100},
                "location": (text_x - 1000, text_y - 60, z)
            })


        # Draw center point (after posts)
        if positions:
            data_list.append({
                "type": "point",
                "location": (cx, cy, cz),
                "dxfattribs": {"layer": "AD_PEN"}
            })
            data_list.append({
                "type": "circle",
                "center": (cx, cy, cz),
                "radius": 35.0,
                "dxfattribs": {"layer": "AD_PEN"}
            })

        # Perimeter in 3D using A..N order with edge labels
        order = [chr(65 + i) for i in range(point_count)]
        dimensions = attrs.get('dimensions') or {}
        for i in range(point_count):
            a = order[i]
            b = order[(i + 1) % point_count]
            if a in post_xy and b in post_xy:
                # Draw perimeter edge
                data_list.append({
                    "type": "line",
                    "start": post_xy[a],
                    "end": post_xy[b],
                    "dxfattribs": {"layer": "AD_STRUCTURE"}
                })
                # Add edge label at midpoint
                edge_key = f"{a}{b}"
                edge_length = _safe_num(dimensions.get(edge_key))
                if edge_length:
                    mid_x = (post_xy[a][0] + post_xy[b][0]) / 2
                    mid_y = (post_xy[a][1] + post_xy[b][1]) / 2
                    mid_z = (post_xy[a][2] + post_xy[b][2]) / 2
                    edge_label = f"{edge_key}\n{int(round(edge_length))}mm"
                    data_list.append({
                        "type": "mtext",
                        "text": edge_label,
                        "dxfattribs": {"layer": "AD_PEN", "char_height": 80, "color": 3, "bg_fill": 1, "bg_fill_color": 7},
                        "location": (mid_x, mid_y, mid_z),
                        "attachment_point": 5
                    })

        # Draw diagonal lines (thinner, less apparent) with labels
        for i in range(point_count):
            for j in range(i + 2, point_count):
                # Skip adjacent edges (already drawn as perimeter)
                if j == (i + 1) % point_count or i == (j + 1) % point_count:
                    continue
                a = order[i]
                b = order[j]
                diag_key_ab = f"{a}{b}"
                diag_key_ba = f"{b}{a}"
                diag_length = _safe_num(dimensions.get(diag_key_ab)) or _safe_num(dimensions.get(diag_key_ba))
                if diag_length and a in post_xy and b in post_xy:
                    # Draw thin diagonal line
                    data_list.append({
                        "type": "line",
                        "start": post_xy[a],
                        "end": post_xy[b],
                        "dxfattribs": {"layer": "AD_PEN", "color": 8, "lineweight": -1}
                    })
                    # Add diagonal label at midpoint
                    mid_x = (post_xy[a][0] + post_xy[b][0]) / 2
                    mid_y = (post_xy[a][1] + post_xy[b][1]) / 2
                    mid_z = (post_xy[a][2] + post_xy[b][2]) / 2
                    diag_label = f"{a}{b}\n{int(round(diag_length))}mm"
                    data_list.append({
                        "type": "mtext",
                        "text": diag_label,
                        "dxfattribs": {"layer": "AD_PEN", "char_height": 60, "color": 8, "bg_fill": 1, "bg_fill_color": 7},
                        "location": (mid_x, mid_y, mid_z),
                        "attachment_point": 5
                    })

        # Workpoints: 3D offset from each post toward 3D center by tensionAllowance
        workpoints_data = attrs.get("workpoints") or {}
        workpoints = {}
        for label, pos in positions.items():
            # Get pre-calculated workpoint
            wp = workpoints_data.get(label)
            if wp:
                wx_local = _safe_num(wp.get("x")) or 0.0
                wy_local = _safe_num(wp.get("y")) or 0.0
                wz_local = _safe_num(wp.get("z")) or 0.0
                
                wx = x_offset + (wx_local - min_x)
                wy = wy_local
                wz = wz_local
                
                workpoints[label] = (wx, wy, wz)
                
                # draw workpoint (red)
                data_list.append({
                    "type": "circle",
                    "center": (wx, wy, wz),
                    "radius": 30.0,
                    "dxfattribs": {"layer": "AD_WORK_LINE", "color": 1}
                })
                data_list.append({
                    "type": "point",
                    "location": (wx, wy, wz),
                    "dxfattribs": {"layer": "AD_WORK_LINE", "color": 1}
                })
                # line from post to workpoint
                if label in post_xy:
                    data_list.append({
                        "type": "line",
                        "start": post_xy[label], 
                        "end": workpoints[label], 
                        "dxfattribs": {"layer": "AD_PEN", "color": 1}
                    })

        # Draw polygon connecting workpoints in 3D (red)
        for i in range(point_count):
            a = order[i]
            b = order[(i + 1) % point_count]
            if a in workpoints and b in workpoints:
                data_list.append({
                    "type": "line",
                    "start": workpoints[a], 
                    "end": workpoints[b], 
                    "dxfattribs": {"layer": "AD_WORK_LINE", "color": 1}
                })

        # Advance offset; if width_local is zero (degenerate), still move by spacing
        advance = width_local if width_local > 0 else 0.0
        x_offset += advance + spacing
        
    return data_list


def generate_dxf(project, download_name: str):
    """Lean DXF: accepts a standalone plain project dict and draws sails.

    Expected minimal shape:
      project = {
        "general": { "name": str, ... },
        "products": [ { "name": str, "productIndex": int, "attributes": { ... } }, ... ]
      }
    """
    doc, msp = new_doc_mm()

    # Reuse extract function
    entities = get_drawing_data(project)

    for e in entities:
        etype = e.get("type")
        if etype == "line":
             msp.add_line(e["start"], e["end"], dxfattribs=e.get("dxfattribs"))
        elif etype == "circle":
             msp.add_circle(e["center"], e["radius"], dxfattribs=e.get("dxfattribs"))
        elif etype == "point":
             msp.add_point(e["location"], dxfattribs=e.get("dxfattribs"))
        elif etype == "text":
             # Use set_placement for TEXT
             msp.add_text(e["text"], dxfattribs=e.get("dxfattribs")).set_placement(e["location"])
        elif etype == "mtext":
             # Use set_location for MTEXT
             m = msp.add_mtext(e["text"], dxfattribs=e.get("dxfattribs"))
             if "location" in e:
                 m.set_location(e["location"], attachment_point=e.get("attachment_point", 1))

    tmp = tempfile.NamedTemporaryFile(suffix=".dxf", delete=False)
    tmp_path = tmp.name
    tmp.close()
    doc.saveas(tmp_path)

    return send_file(
        tmp_path,
        mimetype="application/dxf",
        as_attachment=True,
        download_name=download_name,
        max_age=0,
        etag=False,
        conditional=False,
        last_modified=None,
    )
