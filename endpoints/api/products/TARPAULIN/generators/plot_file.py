import os
import tempfile
from datetime import datetime, timezone
from flask import send_file, after_this_request
import json as JSON_py
from io import BytesIO
from endpoints.api.projects.shared.dxf_utils import new_doc_mm

def get_metadata():
    return {
        "id": "plot_file",
        "name": "Plot File",
        "type": "dxf"
    }

def generate(project, **kwargs):
    """
    Generates a DXF plot file for the TARPAULIN product.
    """
    project_name = project.get("general", {}).get("name", "Unnamed")
    filename = f"{project_name}_plot.dxf"
    return generate_dxf(project, filename)

def _escape_mtext(text):
    """Escape special characters for DXF MTEXT content."""
    if not text:
        return ""
    return text.replace("\\", "\\\\").replace("{", "\\{").replace("}", "\\}")

def generate_dxf(project, download_name: str):
    """Generate DXF for TARPAULIN: rectangles with original on pen layer, final on wheel layer."""
    doc, msp = new_doc_mm()
    
    # 1. Add Project Title and JSON Dump
    gen = project.get("general") or {}
    project_name = gen.get("name") or "Unnamed"
    products_list = project.get("products") or []
    project_desc = f"Project: {project_name} | Tarpaulins: {len(products_list)}"
    date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    msp.add_mtext(project_desc, dxfattribs={"layer": "AD_INFO", "char_height": 1000}).set_location((-3000, 6000))
    msp.add_mtext(f"Generated by AutoDraw v00.02 at {date}", dxfattribs={"layer": "AD_INFO", "char_height": 500}).set_location((-3000, 4500))
    
    json_str = JSON_py.dumps(project, indent=2)
    msp.add_mtext(_escape_mtext(json_str), dxfattribs={"layer": "AD_INFO", "char_height": 20}).set_location((-4000, 3500))

    # 2. Iterate products to draw tarpaulins
    x_offset = 0
    # Move drawing down significant amount to clear the fixed headers at Y=3000-6000
    y_base = -5000 

    for i, product in enumerate(products_list):
        attrs = product.get("attributes") or {}
        length = attrs.get("length", 1000)  # original length in mm
        width = attrs.get("width", 1000)   # original width in mm
        final_length = attrs.get("final_length", length + 100)  # with 50mm pocket each side
        final_width = attrs.get("final_width", width + 100)
        name = product.get("name", f"Tarpaulin {i+1}")
        
        # Tarpaulin Title - positioned nicely above the tarp
        product_title = f"Tarpaulin: {product.get('productIndex', i+1)} | {name} | Original: {length}mm x {width}mm | Final: {final_length}mm x {final_width}mm"
        msp.add_mtext(product_title, dxfattribs={"layer": "AD_INFO", "char_height": 300}).set_location((x_offset, final_width + y_base + 500))
        
        # Draw final rectangle (cut box) on "wheel" layer
        msp.add_line((x_offset, y_base), (x_offset + final_length, y_base), dxfattribs={"layer": "wheel"})
        msp.add_line((x_offset + final_length, y_base), (x_offset + final_length, final_width + y_base), dxfattribs={"layer": "wheel"})
        msp.add_line((x_offset + final_length, final_width + y_base), (x_offset, final_width + y_base), dxfattribs={"layer": "wheel"})
        msp.add_line((x_offset, final_width + y_base), (x_offset, y_base), dxfattribs={"layer": "wheel"})
        
        # Draw original rectangle inside centered (50mm gap) on "pen" layer
        gap = 50
        orig_x = x_offset + gap
        orig_y = gap + y_base
        
        msp.add_line((orig_x, orig_y), (orig_x + length, orig_y), dxfattribs={"layer": "pen"})
        msp.add_line((orig_x + length, orig_y), (orig_x + length, orig_y + width), dxfattribs={"layer": "pen"})
        msp.add_line((orig_x + length, orig_y + width), (orig_x, orig_y + width), dxfattribs={"layer": "pen"})
        msp.add_line((orig_x, orig_y + width), (orig_x, orig_y), dxfattribs={"layer": "pen"})
        
        # Draw Eyelets (from calculated positions)
        calculated_eyelets = attrs.get("calculated_eyelets", [])
        for eyelet in calculated_eyelets:
            # eyelet has x, y relative to tarp origin (0,0)
            lx = eyelet.get("x", 0)
            ly = eyelet.get("y", 0)
            ex = x_offset + lx
            ey = y_base + ly
            side = eyelet.get("side")

            # Check for corners to draw diagonals (45 degrees)
            # Use small tolerance for float comparison
            is_left = lx < 1.0
            is_right = lx > final_length - 1.0
            is_bottom = ly < 1.0
            is_top = ly > final_width - 1.0

            if is_left and is_bottom:
                # Bottom-Left: Diagonal to (100, 100)
                msp.add_line((ex, ey), (ex + 100, ey + 100), dxfattribs={"layer": "pen"})
            elif is_right and is_bottom:
                # Bottom-Right: Diagonal to (-100, 100)
                msp.add_line((ex, ey), (ex - 100, ey + 100), dxfattribs={"layer": "pen"})
            elif is_right and is_top:
                # Top-Right: Diagonal to (-100, -100)
                msp.add_line((ex, ey), (ex - 100, ey - 100), dxfattribs={"layer": "pen"})
            elif is_left and is_top:
                # Top-Left: Diagonal to (100, -100)
                msp.add_line((ex, ey), (ex + 100, ey - 100), dxfattribs={"layer": "pen"})
            else:
                # Not a corner: Draw 100mm line inwards perpendicular to side
                if side == "top":
                    msp.add_line((ex, ey), (ex, ey - 100), dxfattribs={"layer": "pen"})
                elif side == "bottom":
                    msp.add_line((ex, ey), (ex, ey + 100), dxfattribs={"layer": "pen"})
                elif side == "left":
                    msp.add_line((ex, ey), (ex + 100, ey), dxfattribs={"layer": "pen"})
                elif side == "right":
                    msp.add_line((ex, ey), (ex - 100, ey), dxfattribs={"layer": "pen"})
        
        x_offset += final_length + 1000  # Space between tarpaulins
    
    tmp = tempfile.NamedTemporaryFile(suffix=".dxf", delete=False)
    tmp_path = tmp.name
    tmp.close()
    doc.saveas(tmp_path)

    @after_this_request
    def _cleanup(response):
        try:
            os.remove(tmp_path)
        except OSError:
            pass
        return response

    return send_file(
        tmp_path,
        mimetype="application/octet-stream",
        as_attachment=True,
        download_name=download_name,
        max_age=0,
        etag=False,
        conditional=False,
        last_modified=None,
    )
